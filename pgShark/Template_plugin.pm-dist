package Xxx;

use strict;
use warnings;
use pgShark::Utils;
use Net::Pcap qw(:functions);

## TODO
#  * ...

sub new {
	my $class = shift;
	my $args = shift;
	my $pcap = shift;
	$pcap = $$pcap;

	my $self = {
	};

	# set the pcap filter to remove unneeded backend answer
	my $filter = undef;

	# the following filter reject TCP-only stuff and capture only frontend messages
	pcap_compile($pcap, \$filter,
		"((((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)", 0, 0
	);
	pcap_setfilter($pcap, $filter);

	debug(1, "Xxx: Plugin loaded.\n");

	return bless($self, $class);
}

# handle C command (close)
# @param $pg_msg hash with pg message properties
sub deallocate {
	my $self = shift;
	my $pg_msg = shift;
}

## handle P command (parse)
# @param $pg_msg hash with pg message properties
sub process_parse {
	my $self = shift;
	my $pg_msg = shift;
}

## handle command B (bind)
# @param $pg_msg hash with pg message properties
sub process_bind {
	my $self = shift;
	my $pg_msg = shift;
}

## handle command E (execute)
# @param $pg_msg hash with pg message properties
sub process_execute {
	my $self = shift;
	my $pg_msg = shift;
}

## handle command C (close)
# @param $pg_msg hash with pg message properties
sub process_close {
	my $self = shift;
	my $pg_msg = shift;
}

## handle command Q (query)
# @param $pg_msg hash with pg message properties
sub process_query {
	my $self = shift;
	my $pg_msg = shift;
}

## handle command X (terminate)
# @param $pg_msg hash with pg message properties
sub process_disconnect {
	my $self = shift;
	my $pg_msg = shift;
}


sub DESTROY {
	my $self = shift;
#	debug(1, "Xxx: output something usefull here ?\n");
}

1;
